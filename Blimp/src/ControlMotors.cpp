#include "ControlMotors.h"

// Create servo objects to control the ESCs
Servo ESC_1;
Servo ESC_2;
Servo ESC_FLY_FORWARD;

// Create a servo object to control a servo
Servo SERVO;

// If it is set to 0, a band is created around the desired value in which the height is not regulated. This should save energy
#define DEAD_ZONE 0 

unsigned int STOP_POWER = 90; // Default stop power level for ESCs, corresponding to the neutral position.
unsigned int POWER = STOP_POWER;  // Power level for ESCs, ranging from 0 to 180.

/**
 * Initializes all ESCs by attaching them to specific pins and setting initial power levels.
 *
 * This function should be called at the start to ensure all ESCs are properly calibrated
 * and ready to receive further commands.
 */
void InitializeESCs(void) {
    ESC_1.attach(ESC_H_1,1000,2000); // Attach ESC_1 to pin ESC_H_1 with pulse width range 1000 to 2000 microseconds.
    ESC_2.attach(ESC_H_2,1000,2000);
    ESC_FLY_FORWARD.attach(FORWARD_ESC,1000,2000);

    // Calibration - Set all ESCs to stop power
    ESC_1.write(STOP_POWER);
    ESC_2.write(STOP_POWER);
    ESC_FLY_FORWARD.write(STOP_POWER);
    delay(1500);
}

/**
 * Attaches the main servo to a designated pin.
 */
void InitializeSERVO(void) {
    SERVO.attach(SERVO_PIN);
}


/**
 * Controls the steering motor based on input steering angles.
 */
void ControlSteeringMotor(void){
    while(true){
        if (FLY_FORWARD) {
            ESC_FLY_FORWARD.write(POWER_OF_STEERING_MOTOR);
        }else {
            ESC_FLY_FORWARD.write(STOP_POWER);
        }
    }
}

/**
 * Manages the servo movements.
 *
 * This function directs the servo to specific positions, typically in response
 * to user inputs or automatic control signals that adjust device orientation or positioning.
 */
void ControlServo(float angle) {
    float offset = 87;
    SERVO.write(-angle + offset);
}

/**
 * Controls the height based on sensor inputs and target height settings.
 *
 * This function calculates the necessary adjustments to the motor power to maintain
 * or reach the desired height, factoring in real-time sensor feedback and pre-defined limits.
 */
void ControlHeight() {
    unsigned long lastTime = millis(); // Record the current time to manage the timing of the control loop.
    float RateOfChange = 0.3; //[m/s] Define the maximum rate of change for the height adjustment.
    float SampleTimeInSec = ((float)SampleTime)/1000; // Convert sample time from milliseconds to seconds for calculations.
    float CurrentRequiredHeight = CURRENT_HEIGHT;
    float LastRequiredHeight = CurrentRequiredHeight;
    //float alpha = SampleTimeInSec * 0.4; // This was gained from the original filter by Laplace transformation //1.3
    float alpha = SampleTimeInSec / (0.4 + SampleTimeInSec); // This was generated by AI and it works pretty well
    float Force; // Variable to store calculated force.
    float Thrust; // Variable to store calculated thrust.
    float PW; // Variable to store pulse width.
    bool Manual = false;
    WaitWhileDoNotMove();
    while(true){
        unsigned long now = millis();
        double dt = (double)(now - lastTime);
        if(dt >= SampleTime){
            // Shape input data before processing.
            InputShaping(CurrentRequiredHeight, LastRequiredHeight, REQ_HEIGHT, RateOfChange, SampleTimeInSec, alpha);
            C_R_H = CurrentRequiredHeight;
            // Choose controll method
            if (DEAD_ZONE){
                DeadZoneControll(CurrentRequiredHeight, Force, Thrust, PW, Manual);
            }else{
                AutomaticControl(CurrentRequiredHeight, Force, Thrust, PW);
            }
            lastTime = now;
        }else if(dt + 10 < SampleTime) {
            threads.delay(10);
        }
        ESC_1.write(POWER);
        ESC_2.write(POWER);

        while (DoNotMove){ // Pokud jsou manuálně vypnuty motory.
            ESC_1.write(STOP_POWER);
            ESC_2.write(STOP_POWER);
            threads.delay(100);
        }
    }
}

void WaitWhileDoNotMove(void){
    while(DoNotMove){
        threads.delay(50);
    }
}

/**
 * Shape the input so that the desired value change is smooth.
 * This should reduce jumps and oscillations of the airship.
 *
 * @param CurrentRequiredHeight Current required height.
 * @param LastRequiredHeight Last required height.
 * @param TargetRequiredHeight Target height.
 * @param RateOfChange Rate of change of height.
 * @param SampleTimeInSec 
 * @param alpha Smoothing factor for filtering the input.
 */
void InputShaping(float &CurrentRequiredHeight, float &LastRequiredHeight, float TargetRequiredHeight, float RateOfChange, float SampleTimeInSec, float alpha) {
    IntegrateInput(CurrentRequiredHeight, TargetRequiredHeight, RateOfChange, SampleTimeInSec);
    FirstOrderFilter(CurrentRequiredHeight, LastRequiredHeight, alpha);

    // If the target height changes significantly faster than the actual height, this condition will slow it down forcibly   
    if(CurrentRequiredHeight > CURRENT_HEIGHT + 1) CurrentRequiredHeight = CURRENT_HEIGHT + 1;
    else if(CurrentRequiredHeight < CURRENT_HEIGHT - 1) CurrentRequiredHeight = CURRENT_HEIGHT - 1;

    LastRequiredHeight = CurrentRequiredHeight;
}

/**
 * Integrates input. The desired height does not change in leaps and bounds, but follows a ramp.
 *
 * @param CurrentRequiredHeight Current required height of airship.
 * @param TargetRequiredHeight Target required height of airship
 * @param RateOfChange is the rate of change of height in meters per second, which indicates how fast the airship should change height.
*/
void IntegrateInput(float &CurrentRequiredHeight, float TargetRequiredHeight, float RateOfChange, float dt) {
    if (CurrentRequiredHeight < TargetRequiredHeight) {
        CurrentRequiredHeight += RateOfChange * dt;
        if (CurrentRequiredHeight > TargetRequiredHeight) CurrentRequiredHeight = TargetRequiredHeight;
    } else {
        CurrentRequiredHeight -= RateOfChange * dt;
        if (CurrentRequiredHeight < TargetRequiredHeight) CurrentRequiredHeight = TargetRequiredHeight;
    }
}

/**
 * Applies a first-order filter to the input data.
 *
 * @param CurrentRequiredHeight Current value to be filtered.
 * @param LastRequiredHeight Resulting value after filtering.
 * @param alpha Time constant of the filter that determines the response speed.
 */
void FirstOrderFilter(float &CurrentRequiredHeight, float LastRequiredHeight, float alpha) {
    CurrentRequiredHeight = LastRequiredHeight + alpha * (CurrentRequiredHeight - LastRequiredHeight);
}

/**
 * Manages control operations with the dead zone.
 *
 * @param RequiredHeight Current required height
 * @param Force Applied force
 * @param Thrust Level of thrust
 * @param PW Pulse width
 * @param Manual Flag indicating if manual control is enabled.
 */
void DeadZoneControll(float RequiredHeight, float& Force, float& Thrust, float& PW, bool& Manual){
    if (ultrasonicDistanceIsValid && !Manual && abs(CURRENT_HEIGHT-RequiredHeight) < 0.2){ 
        // Vysoko nad zemí se může vytvořit mrtvé pásmo, které šetří baterii
        Manual = true;
        POWER = STOP_POWER;
    }
    else if(!Manual){ // Blízko země => Přesné řízení
        AutomaticControl(RequiredHeight, Force, Thrust, PW);
    }
    else if(Manual && abs(REQ_HEIGHT - CURRENT_HEIGHT) > 0.5){
        Manual = false;
        initialization(); // TODO - možná dát pryč
    }
}

void AutomaticControl(float RequiredHeight, float& Force, float& Thrust, float& PW){
    CalculateOutput(Force, CURRENT_HEIGHT, RequiredHeight);
    Thrust = force_to_thrust(Force);
    PW = thrust_to_PWM(Thrust);
    POWER = map(PW, 1000, 2000, 0, 180);
}

/**
 * Converts force (in newtons) to thrust
 *
 * This function Converts the calculated force necessary to maintain or change height
 * into the equivalent thrust value.
 *
 * @param force Force in newtons that needs to be converted to thrust.
 * @return Equivalent thrust in grams.
 */
float force_to_thrust(float val) {
    const float g = 9.81;
    return val/g;
}

/**
 * Converts thrust (in kilograms) to PWM (ESC) signal to send to ESC.
 * 
 * A 4th st polynomial is used for the conversion , which correctly and very accurately converts the points in the range
 * -100g to 180g (which is also the measured range of the engine).
 * But if a number that is not in this range comes up, 
 * so it would not be converted correctly. Therefore, the value for numbers outside this range is assigned by the hard-given condition.
 * 
 * @param thrust Thrust in kilograms to be converted into a PWM signal.
 * @return PWM signal value ranging from 1000 to 2000 microseconds.
 */
int thrust_to_PWM(float thrust) {
    float a4 = 784284.3567;
    float a3 = -159923.0567;
    float a2 = -12832.6413;
    float a1 = 5836.1500;
    float a0 = 1482.7144;

    float x  = thrust/2;

    if (x > 0.180) {
        return 2000;
    }
    else if (x < -100) {
        return 1000;
    }
    else {
        return int(a4*pow(x, 4) + a3*pow(x, 3) + a2*pow(x, 2) + a1*x + a0);
    }
}
